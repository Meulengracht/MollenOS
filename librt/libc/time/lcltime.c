/*
 * localtime.c
 */

/*
FUNCTION
<<localtime>>---convert time to local representation

INDEX
	localtime
INDEX
	localtime_r

ANSI_SYNOPSIS
	#include <time.h>
	struct tm *localtime(time_t *<[clock]>);
	struct tm *localtime_r(time_t *<[clock]>, struct tm *<[res]>);

TRAD_SYNOPSIS
	#include <time.h>
	struct tm *localtime(<[clock]>)
	time_t *<[clock]>;
	struct tm *localtime(<[clock]>, <[res]>)
	time_t *<[clock]>;
	struct tm *<[res]>;

DESCRIPTION
<<localtime>> converts the time at <[clock]> into local time, then
converts its representation from the arithmetic representation to the
traditional representation defined by <<struct tm>>.

<<localtime>> constructs the traditional time representation in static
storage; each call to <<gmtime>> or <<localtime>> will overwrite the
information generated by previous calls to either function.

<<mktime>> is the inverse of <<localtime>>.

RETURNS
A pointer to the traditional time representation (<<struct tm>>).

PORTABILITY
ANSI C requires <<localtime>>.

<<localtime>> requires no supporting OS subroutines.
*/

#include <internal/_tls.h>
#include <string.h>
#include <time.h>
#include "local.h"

/* Reentrency version of gmtime 
 * Modified implementation by newlib */
struct tm *localtime_r(const time_t *__restrict tim_p, struct tm *__restrict res)
{
	long offset;
	int hours, mins, secs;
	int year;
	__tzinfo_type *const tz = __gettzinfo();
	const int *ip;

	res = gmtime_r(tim_p, res);

	year = res->tm_year + YEAR_BASE;
	ip = __month_lengths[isleap(year)];

	TZ_LOCK;
	_tzset_unlocked();
	if (__daylight)
	{
		if (year == tz->__tzyear || __tzcalc_limits(year))
			res->tm_isdst = (tz->__tznorth
			? (*tim_p >= tz->__tzrule[0].change
			&& *tim_p < tz->__tzrule[1].change)
			: (*tim_p >= tz->__tzrule[0].change
			|| *tim_p < tz->__tzrule[1].change));
		else
			res->tm_isdst = -1;
	}
	else
		res->tm_isdst = 0;

	offset = (res->tm_isdst == 1
		? tz->__tzrule[1].offset
		: tz->__tzrule[0].offset);

	hours = (int)(offset / SECSPERHOUR);
	offset = offset % SECSPERHOUR;

	mins = (int)(offset / SECSPERMIN);
	secs = (int)(offset % SECSPERMIN);

	res->tm_sec -= secs;
	res->tm_min -= mins;
	res->tm_hour -= hours;

	if (res->tm_sec >= SECSPERMIN)
	{
		res->tm_min += 1;
		res->tm_sec -= SECSPERMIN;
	}
	else if (res->tm_sec < 0)
	{
		res->tm_min -= 1;
		res->tm_sec += SECSPERMIN;
	}
	if (res->tm_min >= MINSPERHOUR)
	{
		res->tm_hour += 1;
		res->tm_min -= MINSPERHOUR;
	}
	else if (res->tm_min < 0)
	{
		res->tm_hour -= 1;
		res->tm_min += MINSPERHOUR;
	}
	if (res->tm_hour >= HOURSPERDAY)
	{
		++res->tm_yday;
		++res->tm_wday;
		if (res->tm_wday > 6)
			res->tm_wday = 0;
		++res->tm_mday;
		res->tm_hour -= HOURSPERDAY;
		if (res->tm_mday > ip[res->tm_mon])
		{
			res->tm_mday -= ip[res->tm_mon];
			res->tm_mon += 1;
			if (res->tm_mon == 12)
			{
				res->tm_mon = 0;
				res->tm_year += 1;
				res->tm_yday = 0;
			}
		}
	}
	else if (res->tm_hour < 0)
	{
		res->tm_yday -= 1;
		res->tm_wday -= 1;
		if (res->tm_wday < 0)
			res->tm_wday = 6;
		res->tm_mday -= 1;
		res->tm_hour += 24;
		if (res->tm_mday == 0)
		{
			res->tm_mon -= 1;
			if (res->tm_mon < 0)
			{
				res->tm_mon = 11;
				res->tm_year -= 1;
				res->tm_yday = 364 + isleap(res->tm_year + YEAR_BASE);
			}
			res->tm_mday = ip[res->tm_mon];
		}
	}
	TZ_UNLOCK;

	return (res);
}

/* Normal version of localtime 
 * Modified implementation by newlib */
struct tm *localtime(const time_t * tim_p) {
	struct tm *lclbuf = &(__tls_current()->tm_buffer);
	memset(lclbuf, 0, sizeof(struct tm));
	return localtime_r(tim_p, lclbuf);
}

/* Safe version of localtime  */
int localtime_s(struct tm *__restrict storage, const time_t *__restrict tim_p) {
	memset(storage, 0, sizeof(struct tm));
	localtime_r(tim_p, storage);
    return 0;
}
